using System;
using System.IO;
using Rapicgen.Core.Generators;
using FluentAssertions;
using Xunit;

namespace ApiClientCodeGen.Core.IntegrationTests
{
    [Trait("Category", "SkipWhenLiveUnitTesting")]
    public class ReproduceIssueScenarioTests
    {
        [Fact]
        public void Can_Handle_Issue_Scenario_RMADtls_Path_Structure()
        {
            // Arrange: Reproduce the exact path structure from the issue
            var tempPath = Path.GetTempPath();
            var baseGuid = Guid.NewGuid().ToString();
            
            // Create path structure similar to the reported issue
            var pathStructure = Path.Combine(tempPath, 
                baseGuid,
                "Item",
                "ErpBORMAProcSvc",
                "RMADtlsWithCompanyWithRMANumWithRMALine",
                "RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceipt");
            
            var fileName = "RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceiptRequestBuilder.cs";
            var fullPath = Path.Combine(pathStructure, fileName);
            
            try
            {
                Directory.CreateDirectory(pathStructure);
                
                // Create the file with actual C# content that would be generated
                var content = @"// <auto-generated>
// This file was auto-generated by the Kiota Code Generator.
// </auto-generated>

using Microsoft.Kiota.Abstractions;
using Microsoft.Kiota.Abstractions.Serialization;
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace ErpBORMAProcSvc.Item.RMADtlsWithCompanyWithRMANumWithRMALine.RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceipt
{
    /// <summary>
    /// Builds and executes requests for operations under \Item\{Company}\{RMANum}\{RMALine}\{RMAReceipt}
    /// </summary>
    public class RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceiptRequestBuilder : BaseRequestBuilder
    {
        /// <summary>
        /// Instantiates a new RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceiptRequestBuilder and sets the default values.
        /// </summary>
        /// <param name=""pathParameters"">Path parameters for the request</param>
        /// <param name=""requestAdapter"">The request adapter to use to execute the requests.</param>
        public RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceiptRequestBuilder(Dictionary<string, object> pathParameters, IRequestAdapter requestAdapter) : base(requestAdapter, ""{+baseurl}/Item/{Company}/{RMANum}/{RMALine}/{RMAReceipt}"", pathParameters)
        {
        }
        
        /// <summary>
        /// Instantiates a new RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceiptRequestBuilder and sets the default values.
        /// </summary>
        /// <param name=""rawUrl"">The raw URL to use for the request builder.</param>
        /// <param name=""requestAdapter"">The request adapter to use to execute the requests.</param>
        public RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceiptRequestBuilder(string rawUrl, IRequestAdapter requestAdapter) : base(requestAdapter, rawUrl)
        {
        }
    }
}";

                File.WriteAllText(fullPath, content);
                
                // Create another file to test the merging functionality
                var anotherPath = Path.Combine(pathStructure, "RMADtlAttchesWithCompanyWithRMANumWithRMALineWithDrawingSeq.cs");
                var anotherContent = @"using Microsoft.Kiota.Abstractions;
using System.ComponentModel.DataAnnotations;

namespace ErpBORMAProcSvc.Item.RMADtlsWithCompanyWithRMANumWithRMALine
{
    public class RMADtlAttchesWithCompanyWithRMANumWithRMALineWithDrawingSeq
    {
        [Required]
        public string Company { get; set; }
        
        [Required] 
        public string RMANum { get; set; }
        
        public int RMALine { get; set; }
        
        public int DrawingSeq { get; set; }
    }
}";

                File.WriteAllText(anotherPath, anotherContent);
                
                // Act: This is the operation that was failing in the original issue
                var result = CSharpFileMerger.MergeFiles(Path.Combine(tempPath, baseGuid));
                
                // Assert: Verify the merge was successful
                result.Should().NotBeNullOrWhiteSpace();
                result.Should().Contain("using Microsoft.Kiota.Abstractions;");
                result.Should().Contain("using Microsoft.Kiota.Abstractions.Serialization;");
                result.Should().Contain("using System.ComponentModel.DataAnnotations;");
                result.Should().Contain("RMARcptsWithCompanyWithRMANumWithRMALineWithRMAReceiptRequestBuilder");
                result.Should().Contain("RMADtlAttchesWithCompanyWithRMANumWithRMALineWithDrawingSeq");
                
                // Verify the paths were actually long enough to trigger the issue
                fullPath.Length.Should().BeGreaterThan(150, "Path should be long enough to potentially cause issues");
                
                // Log the path length for debugging
                Console.WriteLine($"Test path length: {fullPath.Length}");
                Console.WriteLine($"Test path: {fullPath}");
            }
            finally
            {
                // Cleanup
                try
                {
                    if (Directory.Exists(Path.Combine(tempPath, baseGuid)))
                    {
                        Directory.Delete(Path.Combine(tempPath, baseGuid), true);
                    }
                }
                catch (Exception)
                {
                    // Ignore cleanup errors
                }
            }
        }
    }
}